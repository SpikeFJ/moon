# 一. 使用场景

1. 当业务对象进行某个操作前/后，触发相关动作
2. 当业务对象的某个属性（如温度数据）满足某个条件（`>`,`<`,`between`,`not`)时，执行某种动作
3. 当业务对象的某个指标（每日、月的A属性合计）满足某个条件时，执行某种动作
4. 当业务对象的某个属性连续N 分钟、小时、日 满足某个条件时，执行某种动作



场景1 类比于在方法执行前后做切面拦截，

场景2,3,4 可以在应用中维护一个内存数据库，维持着每个业务对象的实时（历史）数据

区别在于：

场景2 只需要保持业务对象的当前数据，

场景3 需要统计数据，

场景4 需要历史数据


# 二. 规则

规则包含条件（condition）和动作（action），

一个规则类似于数据库的一条触发器

规则引擎启动后，**当接收到关注的消息** 时，判断条件是否满足，通过则执行动作。



消息的接收，可以有以下实现，如：

1. Socket 实现：一个时刻在监听socket的服务监听
2. 消息中间件 实现：一个消息中间件的消费端，时刻监听者生产者是否有消息，下面的判断都以该实现为样例

---



**如何确定哪些消息是本规则关注的？**

规则的创建，主要是选择条件和动作，条件是因，动作是果。

所以关注哪些消息的责任就落到条件（condition）上了



# 三. 条件（condition）

主要逻辑：

1. 处理消息，即从消息中提取本条件需要的信息
2. 执行条件本体

## 1. 分析

首先我们分析下如下的场景：

【当 A 设备 的 温度>18 且 状态为关闭时】，执行某种动作



1. 两种数据：【温度】和【状态】

   > 这两种数据首先界面要能够选择到，其次规则引擎能够接受到这两种数据的传递

2. 数据来自哪里

   > 两种数据对应着业务对象的两个属性，即业务对象需要对外暴露着两个字段

3. 数据如何监听

   >  两个属性背后需要设置`Topic`（这一步是和消息中间件框架强耦合的）
   >
   > 如果所有数据是一个`Topic`，那么需要在`Message`中区分消息类型，规则引擎启动一个消费者
   >
   > 如果数据是两个`Topic`：`tmpTopic`和`statusTopic`，那规则引擎启动时，就需要启动两个消费者

   

**总结：**

1.  条件上可以选择的字段来源于业务对象上的属性，需要在属性上配置是否对外暴露
2.  属性上需要指定`Topic`

**所以条件是和业务对象强关联的**



## 2. 继续分析

考虑这个场景：【当 **任意** 设备 的 温度>18 且 状态为关闭时】

只和业务类型相关，和具体的对象无关



## 3. 方法拦截

考虑这个场景：【当 任意 设备 **新建**时，如果地址大于10000】，则通知XXX

代码实现：

1. `Device.save`方法上加上委托，固定写死 判断逻辑、通知逻辑
2. `Device.save`方法上加上委托，写入Mq，在Mq消费端写判断逻辑和通知逻辑，这样后续操作和具体保存逻辑结构



现在我们要做的是，将上述逻辑抽取成独立的可以配置的界面操作



1. `save`方法上添加可以暴露的标识，如上述的属性字段暴露
2. 同时对外暴露方法执行前/后可以获取的所有信息
3. 将通知逻辑转变为`action`



# 四. 动作（action）

动作分为两类，通用动作和业务无关，专用动作和业务对象强耦合。

## 1. 通用动作

能够使用的是通用action(如打印日志，发送XX等固定字符)

## 2. 专用动作

还是和业务绑定的action(如打印创建的对象的地址），和业务绑定的需要编码




